"""
Comando Django para verificar a qualidade geral do c√≥digo.

Este comando executa uma s√©rie de verifica√ß√µes autom√°ticas para garantir
que o c√≥digo est√° seguindo as melhores pr√°ticas e padr√µes de qualidade.

Verifica√ß√µes inclu√≠das:
- An√°lise est√°tica com flake8
- Verifica√ß√£o de seguran√ßa
- Cobertura de testes
- Performance de queries
- Conformidade com PEP8
- Documenta√ß√£o de c√≥digo

Uso:
    python manage.py check_quality
    python manage.py check_quality --verbose
    python manage.py check_quality --fix-issues
"""

from django.core.management.base import BaseCommand, CommandError
from django.conf import settings
from django.db import connection
from django.core.cache import cache
import subprocess
import sys
import os


class Command(BaseCommand):
    """
    Comando para verifica√ß√£o de qualidade de c√≥digo.
    
    Executa m√∫ltiplas verifica√ß√µes autom√°ticas e gera relat√≥rio
    detalhado com sugest√µes de melhorias.
    """
    
    help = 'Verifica a qualidade geral do c√≥digo do projeto BusFeed'
    
    def add_arguments(self, parser):
        """Adiciona argumentos opcionais ao comando."""
        parser.add_argument(
            '--verbose',
            action='store_true',
            help='Exibe output detalhado das verifica√ß√µes',
        )
        parser.add_argument(
            '--fix-issues',
            action='store_true',
            help='Tenta corrigir automaticamente problemas encontrados',
        )
        parser.add_argument(
            '--skip-tests',
            action='store_true',
            help='Pula a execu√ß√£o dos testes (mais r√°pido)',
        )
    
    def handle(self, *args, **options):
        """Executa todas as verifica√ß√µes de qualidade."""
        self.verbosity = options.get('verbosity', 1)
        self.verbose = options['verbose']
        self.fix_issues = options['fix_issues']
        self.skip_tests = options['skip_tests']
        
        self.stdout.write(
            self.style.SUCCESS('üîç Iniciando verifica√ß√£o de qualidade do BusFeed...\n')
        )
        
        # Executar todas as verifica√ß√µes
        results = {
            'django_check': self.check_django_configuration(),
            'code_style': self.check_code_style(),
            'security': self.check_security(),
            'performance': self.check_performance(),
            'documentation': self.check_documentation(),
        }
        
        if not self.skip_tests:
            results['tests'] = self.check_tests()
        
        # Gerar relat√≥rio final
        self.generate_report(results)
    
    def check_django_configuration(self):
        """Verifica configura√ß√µes do Django."""
        self.stdout.write('üìã Verificando configura√ß√µes do Django...')
        
        issues = []
        
        try:
            # Executar django check
            result = subprocess.run(
                [sys.executable, 'manage.py', 'check', '--deploy'],
                capture_output=True,
                text=True,
                cwd=settings.BASE_DIR
            )
            
            if result.returncode == 0:
                self.stdout.write(self.style.SUCCESS('  ‚úÖ Configura√ß√µes OK'))
                return {'status': 'ok', 'issues': []}
            else:
                issues = result.stdout.split('\n')
                self.stdout.write(self.style.WARNING('  ‚ö†Ô∏è  Problemas encontrados'))
                if self.verbose:
                    for issue in issues:
                        if issue.strip():
                            self.stdout.write(f'    {issue}')
                            
        except Exception as e:
            issues.append(f'Erro ao executar django check: {e}')
            self.stdout.write(self.style.ERROR('  ‚ùå Erro na verifica√ß√£o'))
        
        return {'status': 'warning' if issues else 'ok', 'issues': issues}
    
    def check_code_style(self):
        """Verifica estilo e formata√ß√£o do c√≥digo."""
        self.stdout.write('üé® Verificando estilo do c√≥digo...')
        
        issues = []
        
        # Verificar com flake8
        try:
            result = subprocess.run(
                ['flake8', '.', '--max-line-length=100', '--exclude=migrations'],
                capture_output=True,
                text=True,
                cwd=settings.BASE_DIR
            )
            
            if result.stdout:
                issues.extend(result.stdout.split('\n'))
                
        except FileNotFoundError:
            issues.append('flake8 n√£o instalado. Execute: pip install flake8')
        except Exception as e:
            issues.append(f'Erro ao executar flake8: {e}')
        
        # Auto-fix com black se solicitado
        if self.fix_issues:
            try:
                subprocess.run(
                    ['black', '.', '--line-length=100'],
                    capture_output=True,
                    cwd=settings.BASE_DIR
                )
                self.stdout.write('  üîß Formata√ß√£o autom√°tica aplicada com black')
            except FileNotFoundError:
                self.stdout.write('  ‚ö†Ô∏è  black n√£o instalado para auto-fix')
        
        status = 'error' if len(issues) > 10 else 'warning' if issues else 'ok'
        
        if status == 'ok':
            self.stdout.write(self.style.SUCCESS('  ‚úÖ Estilo de c√≥digo OK'))
        else:
            self.stdout.write(self.style.WARNING(f'  ‚ö†Ô∏è  {len(issues)} problemas de estilo'))
            if self.verbose and issues:
                for issue in issues[:5]:  # Mostrar apenas os primeiros 5
                    if issue.strip():
                        self.stdout.write(f'    {issue}')
        
        return {'status': status, 'issues': issues}
    
    def check_security(self):
        """Verifica problemas de seguran√ßa."""
        self.stdout.write('üîí Verificando seguran√ßa...')
        
        issues = []
        
        # Verifica√ß√µes b√°sicas de configura√ß√£o
        if settings.DEBUG and not settings.ALLOWED_HOSTS:
            issues.append('ALLOWED_HOSTS vazio em modo DEBUG')
        
        if settings.SECRET_KEY == 'django-insecure-development-key-change-in-production':
            issues.append('SECRET_KEY usando valor padr√£o inseguro')
        
        # Verificar com bandit se dispon√≠vel
        try:
            result = subprocess.run(
                ['bandit', '-r', '.', '-f', 'txt', '--skip', 'B101'],
                capture_output=True,
                text=True,
                cwd=settings.BASE_DIR
            )
            
            if 'No issues identified' not in result.stdout and result.stdout:
                security_issues = result.stdout.split('\n')[-10:]  # √öltimas 10 linhas
                issues.extend(security_issues)
                
        except FileNotFoundError:
            issues.append('bandit n√£o instalado. Execute: pip install bandit')
        except Exception as e:
            issues.append(f'Erro ao executar bandit: {e}')
        
        status = 'error' if len(issues) > 5 else 'warning' if issues else 'ok'
        
        if status == 'ok':
            self.stdout.write(self.style.SUCCESS('  ‚úÖ Seguran√ßa OK'))
        else:
            self.stdout.write(self.style.WARNING(f'  ‚ö†Ô∏è  {len(issues)} problemas de seguran√ßa'))
        
        return {'status': status, 'issues': issues}
    
    def check_performance(self):
        """Verifica performance e otimiza√ß√µes."""
        self.stdout.write('‚ö° Verificando performance...')
        
        issues = []
        
        # Verificar configura√ß√£o de cache
        if 'locmem' in settings.CACHES['default']['BACKEND']:
            issues.append('Cache local em produ√ß√£o pode impactar performance')
        
        # Verificar configura√ß√£o de banco
        if 'sqlite3' in settings.DATABASES['default']['ENGINE'] and not settings.DEBUG:
            issues.append('SQLite em produ√ß√£o pode impactar performance')
        
        # Testar velocidade de conex√£o com banco
        try:
            import time
            start = time.time()
            with connection.cursor() as cursor:
                cursor.execute("SELECT 1")
            db_time = (time.time() - start) * 1000
            
            if db_time > 100:  # Mais de 100ms
                issues.append(f'Conex√£o com banco lenta: {db_time:.2f}ms')
        except Exception as e:
            issues.append(f'Erro ao testar conex√£o com banco: {e}')
        
        # Testar cache
        try:
            import time
            start = time.time()
            cache.set('test_key', 'test_value', 30)
            cache.get('test_key')
            cache_time = (time.time() - start) * 1000
            
            if cache_time > 50:  # Mais de 50ms
                issues.append(f'Cache lento: {cache_time:.2f}ms')
        except Exception as e:
            issues.append(f'Erro ao testar cache: {e}')
        
        status = 'warning' if issues else 'ok'
        
        if status == 'ok':
            self.stdout.write(self.style.SUCCESS('  ‚úÖ Performance OK'))
        else:
            self.stdout.write(self.style.WARNING(f'  ‚ö†Ô∏è  {len(issues)} problemas de performance'))
        
        return {'status': status, 'issues': issues}
    
    def check_tests(self):
        """Verifica cobertura e qualidade dos testes."""
        self.stdout.write('üß™ Verificando testes...')
        
        issues = []
        
        try:
            # Executar testes
            result = subprocess.run(
                [sys.executable, 'manage.py', 'test', '--verbosity=0'],
                capture_output=True,
                text=True,
                cwd=settings.BASE_DIR
            )
            
            if result.returncode != 0:
                issues.append('Alguns testes est√£o falhando')
                if self.verbose:
                    self.stdout.write(result.stdout)
            
            # Verificar cobertura se coverage estiver dispon√≠vel
            try:
                subprocess.run(
                    ['coverage', 'run', '--source=.', 'manage.py', 'test'],
                    capture_output=True,
                    cwd=settings.BASE_DIR
                )
                
                result = subprocess.run(
                    ['coverage', 'report', '--show-missing'],
                    capture_output=True,
                    text=True,
                    cwd=settings.BASE_DIR
                )
                
                # Extrair porcentagem de cobertura
                lines = result.stdout.split('\n')
                for line in lines:
                    if 'TOTAL' in line:
                        parts = line.split()
                        if len(parts) > 3 and '%' in parts[3]:
                            coverage_pct = int(parts[3].replace('%', ''))
                            if coverage_pct < 80:
                                issues.append(f'Cobertura de testes baixa: {coverage_pct}%')
                            break
                        
            except FileNotFoundError:
                issues.append('coverage n√£o instalado. Execute: pip install coverage')
                
        except Exception as e:
            issues.append(f'Erro ao executar testes: {e}')
        
        status = 'error' if any('falhando' in issue for issue in issues) else 'warning' if issues else 'ok'
        
        if status == 'ok':
            self.stdout.write(self.style.SUCCESS('  ‚úÖ Testes OK'))
        else:
            self.stdout.write(self.style.WARNING(f'  ‚ö†Ô∏è  {len(issues)} problemas nos testes'))
        
        return {'status': status, 'issues': issues}
    
    def check_documentation(self):
        """Verifica documenta√ß√£o do c√≥digo."""
        self.stdout.write('üìö Verificando documenta√ß√£o...')
        
        issues = []
        
        # Verificar se arquivos essenciais existem
        essential_docs = ['README.md', 'MELHORIAS_ACESSIBILIDADE.md']
        for doc in essential_docs:
            if not os.path.exists(os.path.join(settings.BASE_DIR, doc)):
                issues.append(f'Documenta√ß√£o faltando: {doc}')
        
        # TODO: Verificar docstrings em fun√ß√µes e classes
        # Isso poderia ser implementado com ast para analisar o c√≥digo
        
        status = 'warning' if issues else 'ok'
        
        if status == 'ok':
            self.stdout.write(self.style.SUCCESS('  ‚úÖ Documenta√ß√£o OK'))
        else:
            self.stdout.write(self.style.WARNING(f'  ‚ö†Ô∏è  {len(issues)} problemas de documenta√ß√£o'))
        
        return {'status': status, 'issues': issues}
    
    def generate_report(self, results):
        """Gera relat√≥rio final da verifica√ß√£o."""
        self.stdout.write('\n' + '='*60)
        self.stdout.write(self.style.SUCCESS('üìä RELAT√ìRIO DE QUALIDADE DO C√ìDIGO'))
        self.stdout.write('='*60)
        
        # Contadores
        total_issues = sum(len(result['issues']) for result in results.values())
        passed_checks = sum(1 for result in results.values() if result['status'] == 'ok')
        total_checks = len(results)
        
        # Status geral
        if total_issues == 0:
            overall_status = self.style.SUCCESS('‚úÖ EXCELENTE')
        elif total_issues < 10:
            overall_status = self.style.WARNING('‚ö†Ô∏è  BOM (com melhorias)')
        else:
            overall_status = self.style.ERROR('‚ùå PRECISA MELHORAR')
        
        self.stdout.write(f'\nStatus Geral: {overall_status}')
        self.stdout.write(f'Verifica√ß√µes Passaram: {passed_checks}/{total_checks}')
        self.stdout.write(f'Total de Problemas: {total_issues}')
        
        # Resumo por categoria
        self.stdout.write('\nüìã Resumo por Categoria:')
        for category, result in results.items():
            status_icon = {
                'ok': '‚úÖ',
                'warning': '‚ö†Ô∏è ',
                'error': '‚ùå'
            }.get(result['status'], '‚ùì')
            
            self.stdout.write(f'  {status_icon} {category.replace("_", " ").title()}: '
                            f'{len(result["issues"])} problemas')
        
        # Recomenda√ß√µes
        if total_issues > 0:
            self.stdout.write('\nüí° Recomenda√ß√µes:')
            
            if results.get('code_style', {}).get('issues'):
                self.stdout.write('  ‚Ä¢ Execute: black . --line-length=100 (formata√ß√£o)')
                self.stdout.write('  ‚Ä¢ Execute: flake8 . (verificar estilo)')
            
            if results.get('security', {}).get('issues'):
                self.stdout.write('  ‚Ä¢ Revise configura√ß√µes de seguran√ßa')
                self.stdout.write('  ‚Ä¢ Execute: bandit -r . (an√°lise de seguran√ßa)')
            
            if results.get('tests', {}).get('issues'):
                self.stdout.write('  ‚Ä¢ Aumente cobertura de testes (meta: >80%)')
                self.stdout.write('  ‚Ä¢ Execute: coverage run --source=. manage.py test')
            
            if results.get('performance', {}).get('issues'):
                self.stdout.write('  ‚Ä¢ Configure Redis para cache em produ√ß√£o')
                self.stdout.write('  ‚Ä¢ Use PostgreSQL em produ√ß√£o')
        
        # Score final
        score = max(0, 100 - (total_issues * 5))
        score_color = (
            self.style.SUCCESS if score >= 90 else
            self.style.WARNING if score >= 70 else
            self.style.ERROR
        )
        
        self.stdout.write(f'\nüéØ Score de Qualidade: {score_color(f"{score}/100")}')
        
        if score >= 90:
            self.stdout.write(self.style.SUCCESS('üèÜ Parab√©ns! C√≥digo de alta qualidade!'))
        elif score >= 70:
            self.stdout.write(self.style.WARNING('üìà Bom c√≥digo, mas h√° espa√ßo para melhorias'))
        else:
            self.stdout.write(self.style.ERROR('üîß C√≥digo precisa de aten√ß√£o urgente'))
        
        self.stdout.write('\n' + '='*60 + '\n') 